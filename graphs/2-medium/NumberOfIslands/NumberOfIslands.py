from collections import deque

class Solution(object):
    def numIslands(self, grid):
        if not grid: 
            return 0 
        rows, cols = len(grid), len(grid[0])
        visited = set()
        islands = 0
        def explore(r, c): 
            queue = deque([(r, c)])
            visited.add((r, c))
            while queue: 
                row, col = queue.popleft()
                directions = [(1,0), (-1,0), (0,1), (0,-1)]
                for dr, dc in directions: 
                    rowNeighbor, colNeighbor = row + dr, col + dc
                    if (0 <= rowNeighbor < rows and 0 <= colNeighbor < cols and
                    grid[rowNeighbor][colNeighbor] == "1" and (rowNeighbor, colNeighbor) not in visited): 
                        queue.append([rowNeighbor, colNeighbor])
                        visited.add((rowNeighbor, colNeighbor))
        for r in range(rows): 
            for c in range(cols): 
                if grid[r][c] == "1" and (r, c) not in visited: 
                    explore(r, c)
                    islands += 1
        return islands

if __name__ == "__main__":
    sol = Solution()
    tests = [
        ([['1','1','1','1','0'],['1','1','0','1','0'],['1','1','0','0','0'],['0','0','0','0','0']], 1),
        ([['1','1','0','0','0'],['1','1','0','0','0'],['0','0','1','0','0'],['0','0','0','1','1']], 3),
        ([['1','0'],['0','1']], 2),
        ([['0','0'],['0','0']], 0),
        ([['1','1','1'],['0','1','0'],['1','1','1']], 1),
        ([['1','1'],['1','1']], 1),
        ([['0','1'],['0','0']], 1),
        ([['1']], 1),
        ([['0']], 0),
        ([['1','0','1'],['0','1','0'],['1','0','1']], 5),
        ([['1','1','1','1'],['0','0','0','0'],['1','1','1','1']], 2),
        ([['1','1','1'],['1','0','1'],['1','1','1']], 1),
        ([['1','1','1'],['0','0','0'],['1','1','1']], 2),
        ([['1','0','0'],['1','1','0'],['0','0','1']], 3),
        ([['1','1','1'],['1','1','1'],['1','1','1']], 1),
        ([['0','0','0'],['0','0','0'],['0','0','0']], 0),
        ([['1','0','1','0','1'],['0','1','0','1','0'],['1','0','1','0','1']], 5),
        ([['1','1','1','1','1'],['0','0','0','0','0'],['1','1','1','1','1']], 2),
        ([['1','1','1'],['1','1','1'],['1','1','1'],['0','0','0']], 1),
        ([['1','1','1'],['0','0','0'],['1','1','1'],['1','1','1']], 2),
        ([['1','0','0'],['0','1','0'],['0','0','1'],['1','1','1']], 4),
        ([['1','1','1'],['1','0','1'],['1','1','1'],['0','0','0']], 1),
        ([['1','1','1'],['1','1','1'],['1','1','1'],['1','0','1']], 1),
        ([['1','1','1'],['0','0','0'],['1','1','1'],['0','1','0']], 3),
        ([['1','1','1'],['1','0','1'],['1','1','1'],['0','0','0']], 1),
        ([['1','1','1'],['1','1','1'],['0','0','0'],['1','1','1']], 2),
        ([['1','0','0'],['1','1','0'],['0','0','1'],['1','1','1']], 3),
        ([['1','1','1'],['1','1','1'],['1','1','1'],['0','0','0']], 1),
        ([['1','0','1'],['0','1','0'],['1','0','1'],['1','1','1']], 5),
        ([['1','1','1','1'],['1','1','1','1'],['0','0','0','0']], 1),
        ([['1','1','1','1'],['0','0','0','0'],['1','1','1','1']], 2),
        ([['1','1','1'],['1','1','1'],['0','0','0']], 1),
        ([['1','0'],['0','1']], 2),
        ([['0','0'],['0','0']], 0)
    ]
    for grid, expected in tests:
        result = sol.numIslands([row[:] for row in grid])
        print(f"Input: {grid}")
        print("Output:", result)
        print("Expected:", expected)
        print("Correct:", result == expected)
        print()
